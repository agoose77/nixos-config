#!/usr/bin/env python3
import subprocess
import argparse
import paho.mqtt.client as mqtt
import socket
import json
import time

host = socket.gethostname()

parser = argparse.ArgumentParser()
parser.add_argument("config", help="Config in a JSON file")

args = parser.parse_args()
with open(args.config, "r") as f:
    config = json.load(f)

mqttc = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)
if config.get("tls"):
    mqttc.tls_set()
if config.get("username") and config.get("password"):
    mqttc.username_pw_set(username=config["username"], password=config["password"])
mqttc.connect(config["host"], config["port"], 60)
mqttc.loop_start()


def announce_discovery(client, config):
    state = {
        "name": config["name"],
        "stat_t": config["stateTopic"],
        "device_class": "occupancy",
        "device": {
            "suggested_area": config["deviceArea"],
            "ids": config["deviceIds"],
            "name": config["deviceName"],
        },
        "origin": {"name": "idle-monitor"},
        "unique_id": f"idle-monitor-{config['deviceName']}-occupancy",
        "payload_on": "active",
        "payload_off": "idle",
    }
    mqttc.publish(config["discoveryTopic"], json.dumps(state))


timeout = config["timeout"]
interval = config.get("interval", 60)
topic = config["stateTopic"]

try:
    announce_discovery(mqttc, config)
    time.sleep(10)

    mqttc.publish(topic, "active")
    t_first_idle = None

    while True:
        try:
            result = subprocess.run(
                ["wayidle", "--timeout", str(interval)], timeout=interval * 1.5
            )
        except subprocess.TimeoutExpired:
            mqttc.publish(topic, "active")
            t_first_idle = None
        else:
            if t_first_idle is None:
                t_first_idle = time.monotonic()
            elif time.monotonic() - t_first_idle >= timeout:
                mqttc.publish(topic, "idle")
finally:
    mqttc.loop_stop()
